<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>H25 Project 2 – ArrayList &amp; LinkedList: H25_project2_philipef_stanisok_susanhop</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">H25 Project 2 – ArrayList &amp; LinkedList
   </div>
   <div id="projectbrief">Implementation and analysis of ArrayList, LinkedList and LinkedArrayList with tests and performance measurements.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md__r_e_a_d_m_e.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">H25_project2_philipef_stanisok_susanhop </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a></p>
<p>Project 2 for philipef (<a href="#" onclick="location.href='mai'+'lto:'+'phi'+'li'+'pef'+'@m'+'ail'+'.u'+'io.'+'no'; return false;">phili<span class="obfuscator">.nosp@m.</span>pef@<span class="obfuscator">.nosp@m.</span>mail.<span class="obfuscator">.nosp@m.</span>uio.<span class="obfuscator">.nosp@m.</span>no</a>) and stanisok (<a href="#" onclick="location.href='mai'+'lto:'+'sta'+'ni'+'sok'+'@m'+'ail'+'.u'+'io.'+'no'; return false;">stani<span class="obfuscator">.nosp@m.</span>sok@<span class="obfuscator">.nosp@m.</span>mail.<span class="obfuscator">.nosp@m.</span>uio.<span class="obfuscator">.nosp@m.</span>no</a>) and susanhop (<a href="#" onclick="location.href='mai'+'lto:'+'sus'+'an'+'hop'+'@m'+'ail'+'.u'+'io.'+'no'; return false;">susan<span class="obfuscator">.nosp@m.</span>hop@<span class="obfuscator">.nosp@m.</span>mail.<span class="obfuscator">.nosp@m.</span>uio.<span class="obfuscator">.nosp@m.</span>no</a>)</p>
<p>GitHub UIO URL: <a href="https://github.uio.no/IN1910/H25_project2_philipef_stanisok_susanhop/tree/main">https://github.uio.no/IN1910/H25_project2_philipef_stanisok_susanhop/tree/main</a></p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md2"></a>
Commands</h1>
<p>To compile the project:</p>
<ul>
<li>Write 'make all' in terminal to make all the files that shall be used in the project. This entails all the files for all the exercises.</li>
</ul>
<p>To run the project:</p>
<ul>
<li>Write 'make run-all' in terminal to run all the main functions. This runs all the programs in the projects simultaneously.</li>
<li>If you want to run the files one-by-one, simply write './path/chosen_file' in the terminal.<ul>
<li>Note: The path may be /build/ if you want to run the output files generated. If you want to run the test-files, simply write './test_chosen_file' in terminal.</li>
</ul>
</li>
</ul>
<p>To clean the project:</p>
<ul>
<li>Write 'make clean' in the terminal. This removes all the output files generated in the /build/ directory.</li>
<li>Note: It does not remove the genereated files like the .txt- and .png-file(s).</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md3"></a>
List of exercises I managed to run and compile</h1>
<p>We managed to run and compile all the files for all the parts. Furthermore, all the tests work without problem and looks correct. The generated files also look sound and align with expectations.</p>
<p>List:</p>
<ul>
<li><a class="el" href="class_array_list.html" title="A dynamic array-based list that grows automatically as elements are added.">ArrayList</a> (Part 1)</li>
<li><a class="el" href="class_linked_list.html" title="A doubly linked list object of class LinkedList.">LinkedList</a> (Part 2)</li>
<li>Timing and comparison (Part 3)</li>
<li><a class="el" href="class_linked_array_list.html" title="A doubly linked list class, where each node holds an ArrayList object.">LinkedArrayList</a> (Part 4)</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md4"></a>
Task 3a</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md5"></a>
Algorithm analyses for ArrayList and LinkedList</h2>
<p>When analyzing algorithms, it is beneficial to have a way to describe the cost of the operations it needs in terms of time complexity for the algorithm. We use Big-O notation to abstract over the results.</p>
<ul>
<li>Big O notation gives us an upper-bound regarding the time complexity´s increment in accordance with the increase of input n. An example is that O(1), which is constant time complexity will be constant regardless of the input. O(n), linear time complexity constitutes a linear growth in accordance to the input n.</li>
<li>Amortized complexity is used when the worst case happens occasionally and the average running time is lower. By doing this we can get a clear grasp of the difference in theory and the algorithms used in the real world. It is important to have this kind of algorithm analysis with big-O and amortized complexity, since we can learn which operations and datastructures to use in different contexts.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6"></a>
Functions analyzed</h2>
<ol type="1">
<li>Get element at index i<ul>
<li><a class="el" href="class_array_list.html" title="A dynamic array-based list that grows automatically as elements are added.">ArrayList</a>: Time complexity of O(1), constant time. The reason is that the elements are directly next to each other in memory, therefore we can access the elements using pointers, thereby jumping straight to the element instead of traversing the list.</li>
<li><a class="el" href="class_linked_list.html" title="A doubly linked list object of class LinkedList.">LinkedList</a>: Time complexity of O(n), linear time. The reason is that why dont store elements contiguosly in memory, but rather having pointers from the nodes to the next nodes. This means that in the worst case, we need to traverse the whole list to find an element. We can minimize the cost in a doubly linked list by choosing either head or tail, but it will still grow in linear time.</li>
</ul>
</li>
<li>Insert at front<ul>
<li><a class="el" href="class_array_list.html" title="A dynamic array-based list that grows automatically as elements are added.">ArrayList</a>: Time complexity of O(n), linear time. The reason is that when we insert an element at the front of the arraylist, we need to shift the position of all the other nodes.</li>
<li><a class="el" href="class_linked_list.html" title="A doubly linked list object of class LinkedList.">LinkedList</a>: Time complexity of O(1), constant time. The rason is that the header pointer can be replaced by the new element, and the original header can set it previous pointer to point at the new header. This means no other ondes need to be shifted.</li>
</ul>
</li>
<li>Insert at back (append)<ul>
<li><a class="el" href="class_array_list.html" title="A dynamic array-based list that grows automatically as elements are added.">ArrayList</a>: Time complexity of O(n), linear time in the worst case, but O(1) amortized time complexity for average cases. The reason is that for the constant time complexity method, we just select the tail node to be the new element and assign prev and next pointers to it. This is the average case, but we can also have the case where the <a class="el" href="class_array_list.html" title="A dynamic array-based list that grows automatically as elements are added.">ArrayList</a> object is full and when we try to append, we end up having to resize the array. Resizing takes O(n) time, so O(1) time for the append plus O(n) time for the copy into a new array equals a total time complexity of O(n) in the worst case.</li>
<li><a class="el" href="class_linked_list.html" title="A doubly linked list object of class LinkedList.">LinkedList</a>: Time complexity of O(1), constant time. The reason is that we can just update the tail pointer for the newly allocated node and do the pointer updates.</li>
</ul>
</li>
<li>Insert in the middle (at index i)<ul>
<li><a class="el" href="class_array_list.html" title="A dynamic array-based list that grows automatically as elements are added.">ArrayList</a>: Time complexity of O(n), linear time. The reason is the same as for insertion at the front, since we need to shift all elements occuring after one position.</li>
<li><a class="el" href="class_linked_list.html" title="A doubly linked list object of class LinkedList.">LinkedList</a>: Time complexity of O(n), linear time. The same reason as insertion at front, since we need to traverse from head or tail node until we reach node at index i and then do a insertion that takes O(1) time (neighbour relinking only here). The cost can be reduced by selecting a smarter start pointer here as well.</li>
</ul>
</li>
<li>Remove from front<ul>
<li><a class="el" href="class_array_list.html" title="A dynamic array-based list that grows automatically as elements are added.">ArrayList</a>: Time complexity of O(n), linear time. The reason is that we need to shift the position of all elements occurring later one position to the left.</li>
<li><a class="el" href="class_linked_list.html" title="A doubly linked list object of class LinkedList.">LinkedList</a>: Time complexity of O(1), constant time. The reason is that we can just change the header pointer to the new element and update the next node to point to the new node and vice versa.</li>
</ul>
</li>
<li>Remove from back<ul>
<li><a class="el" href="class_array_list.html" title="A dynamic array-based list that grows automatically as elements are added.">ArrayList</a>: Time complexity of O(n), linear time complexity in the worst case. O(1), amortized constant time complexity on average. The reason is that normally we will just decrement the size counter for the array, but if we end up under 25% capacity usage, the _shrink_to_fit() function gets called, which copies all elements over in a smaller array, which takes O(n) time.</li>
<li><a class="el" href="class_linked_list.html" title="A doubly linked list object of class LinkedList.">LinkedList</a>: Time complexity of O(1), constant time. The reason it is constant time is just that we can update the tail pointer to be tail-&gt;prev.</li>
</ul>
</li>
<li>Remove from middle (at index i)<ul>
<li><a class="el" href="class_array_list.html" title="A dynamic array-based list that grows automatically as elements are added.">ArrayList</a>: Time complexity of O(n), linear time complexity. The reason is that we need to shift all elements one position from the middle to the right.</li>
<li><a class="el" href="class_linked_list.html" title="A doubly linked list object of class LinkedList.">LinkedList</a>: Time complexity of O(n), linear time complexity. The reason is that we need to traverse the list to the index to remove it.</li>
</ul>
</li>
<li>Print the list<ul>
<li><a class="el" href="class_array_list.html" title="A dynamic array-based list that grows automatically as elements are added.">ArrayList</a>: Time complexity of O(n), linear time complexity. The reason is simply that we need to visit every node in the array and print it.</li>
<li><a class="el" href="class_linked_list.html" title="A doubly linked list object of class LinkedList.">LinkedList</a>: Time complexity of O(n), linear time complexity. The reason is that we need to visit every node in the linked list and print it.</li>
</ul>
</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7"></a>
Conclusion:</h2>
<ul>
<li><a class="el" href="class_array_list.html" title="A dynamic array-based list that grows automatically as elements are added.">ArrayList</a> has contiguos memory placement, which gives it constant time lookup and appending, however operations on other parts of the array as front and middle require shifting of the other elements which results in linear time complexity.</li>
<li><a class="el" href="class_linked_list.html" title="A doubly linked list object of class LinkedList.">LinkedList</a> excels at insertions and deletions at the ends in constant time, it is also efficient at middle access operations since it does not need to shift indexes. Traversal cost is linear. So choosing between the two datastructures is up to the developers´ goals, where <a class="el" href="class_array_list.html" title="A dynamic array-based list that grows automatically as elements are added.">ArrayList</a> is beneficial for many lookups and appends, while <a class="el" href="class_linked_list.html" title="A doubly linked list object of class LinkedList.">LinkedList</a> is beneficial for insertions and removals from various parts of the list.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8"></a>
Task 3c</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9"></a>
Predictions and result</h2>
<p>From task 3a we predicted that:</p>
<ul>
<li>Arraylist: get() -&gt; O(1) and insert_front() -&gt; O(n)</li>
<li><a class="el" href="class_linked_list.html" title="A doubly linked list object of class LinkedList.">LinkedList</a>: get() -&gt; O(n) and insert_front() -&gt; O(1)</li>
</ul>
<p>From task 3b we measured these results:</p>
<ul>
<li><a class="el" href="class_array_list.html" title="A dynamic array-based list that grows automatically as elements are added.">ArrayList</a> get()-function for average microseconds per access:<ul>
<li>100 -&gt; 0.003</li>
<li>1000 -&gt; 0.003</li>
<li>10000 -&gt; 0.002</li>
<li>100000 -&gt; 0.002</li>
<li>These values represent a "flat" line on the graph, meaning it is in constant time complexity.</li>
</ul>
</li>
<li><a class="el" href="class_array_list.html" title="A dynamic array-based list that grows automatically as elements are added.">ArrayList</a> insert_front()-function for average microseconds per insert:<ul>
<li>100 -&gt; 0.06</li>
<li>1000 -&gt; 0.117</li>
<li>10000 -&gt; 0.7773</li>
<li>100000 -&gt; 4.38338</li>
<li>These values represent a linear line on the graph, meaning it is in linear time complexity.</li>
</ul>
</li>
<li><a class="el" href="class_linked_list.html" title="A doubly linked list object of class LinkedList.">LinkedList</a> get()-function for average microseconds per access:<ul>
<li>100 -&gt; 0.02</li>
<li>1000 -&gt; 0.171</li>
<li>10000 -&gt; 5.625</li>
<li>100000 -&gt; 53.903</li>
<li>These values represent a linear line on the graph, meaning it is in linear time complexity.</li>
</ul>
</li>
<li><a class="el" href="class_linked_list.html" title="A doubly linked list object of class LinkedList.">LinkedList</a> insert_front()-function for average microseconds per insert:<ul>
<li>100 -&gt; 0.01</li>
<li>1000 -&gt; 0.0012</li>
<li>10000 -&gt; 0.0094</li>
<li>100000 -&gt; 0.0081</li>
<li>These values represent a "flat" line on the graph (Even decreasing as N grows), meaning it is in constant time complexity.</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10"></a>
Conclusion:</h2>
<p>The predictions from task 3a corresponds with the results from task 3b. There were some small surprises that was unexpected, but after reading some articles it seems the likely cause might be hardware, cache effects and pointer chasing, there was also decrease in the constant trend for insert-front, but that may be due to more efficient lookups and warmer components that increases the efficiency and reduces latency. Overall the outputs to the txt files and the graphs from plot looks as expected and natural.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md11"></a>
Documentation Notes</h1>
<ul>
<li>The documentations for the functions and classes were written extensively in the header files, and just short one-liners in the source files.</li>
<li>The reason was to avoid duplication of documentation and unnecessarily long source files that become unorganized. I read that this was the way to do it in real life as well, in other words that this is the best documenation convention.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md12"></a>
Use of AI</h1>
<ul>
<li>Some of the Doxygen documentation structure and README wording was generated and refined with OpenAI´s ChatGPT.</li>
<li>All documentation and comments were revised and edited to accurately represent our projects files and structure.</li>
<li>All source files, header files and test files were programmed by us. AI was only used for occasional debugging and explanation support. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
